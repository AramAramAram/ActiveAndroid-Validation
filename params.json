{"name":"ActiveAndroid-validation","tagline":"Simple validation framework on top of ActiveAndroid ORM.","body":"# ActiveAndroid-Validation\r\n\r\n## About\r\n\r\nAn extension to [ActiveAndroid](http://github.com/pardom/ActiveAndroid) adding validation functionality to models, sticking to the simple-to-use way of the ActiveAndroid library.\r\n\r\nI was looking for a simple ORM framework for Android and came across ActiveAndroid, an elegant active-record-like solution very easy to use. Ok, now I have easy to use persistence in my application, but I still have to implement validation on the model fields before saving. ActiveAndroid allows to define NOT NULL or UNIQUE constraints in the database, but it always saves model silently, even if the save failed due to constraint violation. Now I can execute all checks easily before trying to save the model - this covers not only simple field value checks, but also data-related constraints such as the *Unique* constraint.\r\n\r\n## Example\r\n\r\nTo define validation rules, just annotate your model fields with constraints in a manner inspired by [bean validation (JSR 349)](http://beanvalidation.org/1.1). To add validation functionality to your model, subclass **ValidatingModel** instead of **Model**:\r\n\r\n```java\r\npublic static class TestModel extends ValidatingModel {\r\n\r\n\t@Column(name = \"foo\")\r\n\t@NotNull(message = \"This cannot be null!\")\r\n\tprivate Object testField;\r\n\r\n\tpublic Object getTestField() {\r\n\t\treturn testField;\r\n\t}\r\n\r\n\tpublic void setTestField(Object testField) {\r\n\t\tthis.testField = testField;\r\n\t}\r\n}\r\n```\r\n\r\nNow, to validate the model, simply call **isValid()**:\r\n\r\n```java\r\nTestModel model = new TestModel();\r\nif (model.isValid()) {\r\n\t//yay, we're valid!\r\n} else {\r\n\t//model is not valid, deal with it!\r\n\tList<ValidationError> errors = model.getErrors();\r\n\t//now you can process the errors, display to the user, etc.\r\n}\r\n\r\n//Or combined with the save method\r\ntry {\r\n\tmodel.saveOrThrow(); // this wraps validation around the save() method of the Model\r\n} catch (ValidationException ve) {\r\n\tList<ValidationError> errors = ve.getErrors();\r\n\t//handle errors here\r\n}\r\n```\r\n\r\nWhat if I already have my own customised/subclassed models? Just wrap a validation layer on top of your model:\r\n\r\n``` java\r\nIModelSupport<TestModel> support = ModelSupportFactory.wrapModel(model);\r\n\r\nboolean valid = support.isValid(); // now you have all that jazz from Validating model\r\nLong modelId = support.getId();\r\nsupport.save();\r\nsupport.saveOrThrow();\r\nsupport.delete();\r\n.\r\n.\r\n.\r\n\r\n//with a little difference as it is a wrapper, not subclass:\r\nObject myValue = support.getFieldValue(\"testField\");\r\nsupport.setFieldValue(\"testField\", someObject);\r\n\r\n//you can always get to your original model\r\nMyCustomModel model = support.getModel();\r\n```\r\n\r\n## Documentation\r\n\r\nI will be adding topics gradually, I just do not have them ready at the moment.\r\n\r\n* ValidatingModel\r\n* Wrapping existing model - ModelSupportFactory\r\n* Built-in constraints\r\n* Defining your own constraints\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}